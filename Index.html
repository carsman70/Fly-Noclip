-- ScriptBlock — Fly + Noclip version (based on your previous "perfect" script)
-- Paste into StarterPlayer > StarterPlayerScripts (replace old LocalScript)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TextService = game:GetService("TextService")
local ContentProvider = game:GetService("ContentProvider")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Capture game defaults on first character spawn
local GAME_DEFAULT_WALKSPEED = 16
local MAX_VALUE = 1000
local SNAP = 5

local DISCORD_INVITE = "https://discord.gg/9mTKFv5HR"

-- create ScreenGui
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "ScriptBlock_GUI"
screenGui.ResetOnSpawn = false
screenGui.DisplayOrder = 1000
screenGui.Parent = playerGui

-- main UI
local FRAME_W, FRAME_H = 360, 240
local mainFrame = Instance.new("Frame", screenGui)
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, FRAME_W, 0, FRAME_H)
mainFrame.Position = UDim2.new(0.5, -FRAME_W/2, 0.45, -FRAME_H/2)
mainFrame.BackgroundColor3 = Color3.fromRGB(12,12,12)
mainFrame.BackgroundTransparency = 0.18
mainFrame.BorderSizePixel = 0
mainFrame.ClipsDescendants = true
Instance.new("UICorner", mainFrame).CornerRadius = UDim.new(0,10)

local titleBar = Instance.new("Frame", mainFrame)
titleBar.Name = "TitleBar"
titleBar.Size = UDim2.new(1,0,0,36)
titleBar.BackgroundTransparency = 1
local titleLabel = Instance.new("TextLabel", titleBar)
titleLabel.Name = "TitleLabel"
titleLabel.Size = UDim2.new(0.6, -12, 1, 0)
titleLabel.Position = UDim2.new(0,12,0,0)
titleLabel.BackgroundTransparency = 1
titleLabel.Text = "ScriptBlock"
titleLabel.TextColor3 = Color3.new(1,1,1)
titleLabel.Font = Enum.Font.GothamBold
titleLabel.TextSize = 16
titleLabel.TextXAlignment = Enum.TextXAlignment.Left

local minBtn = Instance.new("TextButton", titleBar)
minBtn.Name = "Minimize"; minBtn.Size = UDim2.new(0,30,0,26); minBtn.Position = UDim2.new(1,-76,0,5)
minBtn.BackgroundColor3 = Color3.fromRGB(70,70,70); minBtn.Text = "—"; minBtn.Font = Enum.Font.GothamBold; minBtn.TextSize = 16
Instance.new("UICorner", minBtn).CornerRadius = UDim.new(0,6)
local closeBtn = Instance.new("TextButton", titleBar)
closeBtn.Name = "Close"; closeBtn.Size = UDim2.new(0,30,0,26); closeBtn.Position = UDim2.new(1,-40,0,5)
closeBtn.BackgroundColor3 = Color3.fromRGB(140,20,20); closeBtn.Text = "X"; closeBtn.Font = Enum.Font.GothamBold; closeBtn.TextSize = 16
Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0,6)

local body = Instance.new("Frame", mainFrame)
body.Name = "Body"; body.Size = UDim2.new(1,0,1,-36); body.Position = UDim2.new(0,0,0,36); body.BackgroundTransparency = 1

local controlsFrame = Instance.new("Frame", body)
controlsFrame.Name = "Controls"; controlsFrame.Size = UDim2.new(1,-24,0,140); controlsFrame.Position = UDim2.new(0,12,0,12)
controlsFrame.BackgroundTransparency = 1; controlsFrame.Visible = true

-- Helper to create rows (we will only have Speed row below buttons)
local function createSliderRow(parent, y, labelText, default)
    local row = Instance.new("Frame", parent)
    row.Size = UDim2.new(1,0,0,40); row.Position = UDim2.new(0,0,0,y); row.BackgroundTransparency = 1

    local lbl = Instance.new("TextLabel", row)
    lbl.Size = UDim2.new(0,100,1,0); lbl.Position = UDim2.new(0,0,0,0)
    lbl.BackgroundTransparency = 1; lbl.Text = labelText; lbl.TextColor3 = Color3.new(1,1,1)
    lbl.Font = Enum.Font.Gotham; lbl.TextSize = 14; lbl.TextXAlignment = Enum.TextXAlignment.Left

    local sampleSize = TextService:GetTextSize("1000", 14, Enum.Font.Gotham, Vector2.new(1000,1000))
    local boxWidth = math.clamp(math.ceil(sampleSize.X) + 10, 36, 64)

    local valueBox = Instance.new("TextBox", row)
    valueBox.Size = UDim2.new(0, boxWidth, 1, -6)
    valueBox.Position = UDim2.new(1, -(boxWidth + 16), 0, 3)
    valueBox.BackgroundTransparency = 0.3
    valueBox.Text = tostring(default)
    valueBox.ClearTextOnFocus = false
    valueBox.Font = Enum.Font.Gotham
    valueBox.TextSize = 14
    valueBox.TextColor3 = Color3.new(1,1,1)
    valueBox.TextXAlignment = Enum.TextXAlignment.Center
    Instance.new("UICorner", valueBox).CornerRadius = UDim.new(0,6)

    local track = Instance.new("Frame", row)
    track.Size = UDim2.new(1, -170, 0, 12); track.Position = UDim2.new(0,110,0,14)
    track.BackgroundColor3 = Color3.fromRGB(120,120,120); track.BorderSizePixel = 0
    Instance.new("UICorner", track).CornerRadius = UDim.new(0,6)

    local fill = Instance.new("Frame", track)
    fill.Size = UDim2.new(default / MAX_VALUE, 0, 1, 0); fill.BackgroundColor3 = Color3.fromRGB(190,190,190)
    Instance.new("UICorner", fill).CornerRadius = UDim.new(0,6)

    local knob = Instance.new("ImageButton", track)
    knob.Size = UDim2.new(0,18,0,18); knob.AnchorPoint = Vector2.new(0.5,0.5)
    knob.Position = UDim2.new(default / MAX_VALUE, 0, 0.5, 0)
    knob.BackgroundColor3 = Color3.fromRGB(230,230,230); knob.BorderSizePixel = 0; knob.AutoButtonColor = false
    Instance.new("UICorner", knob).CornerRadius = UDim.new(0,9)

    return {
        Row = row, Label = lbl, ValueBox = valueBox, Track = track,
        Fill = fill, Knob = knob, Value = default, Dragging = false, SavedValue = default,
        DefaultPlaceholder = default
    }
end

-- Buttons area (stacked vertically)
local btnY = 0
local function createToggleButton(parent, y, text)
    local btn = Instance.new("TextButton", parent)
    btn.Size = UDim2.new(0,160,0,30)
    btn.Position = UDim2.new(0, 8, 0, y)
    btn.BackgroundColor3 = Color3.fromRGB(110,110,110)
    btn.Text = text
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 14
    btn.TextColor3 = Color3.new(1,1,1)
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0,6)

    -- squircle indicator to the right
    local indicator = Instance.new("Frame", parent)
    indicator.Size = UDim2.new(0,34,0,30)
    indicator.Position = UDim2.new(0, 8 + 160 + 8, 0, y)
    indicator.BackgroundColor3 = Color3.fromRGB(40,40,40)
    Instance.new("UICorner", indicator).CornerRadius = UDim.new(0,10)

    local indText = Instance.new("TextLabel", indicator)
    indText.Size = UDim2.new(1, -6, 1, 0)
    indText.Position = UDim2.new(0,3,0,0)
    indText.BackgroundTransparency = 1
    indText.Text = "OFF"
    indText.Font = Enum.Font.GothamBold
    indText.TextSize = 14
    indText.TextColor3 = Color3.new(1,1,1)
    indText.TextXAlignment = Enum.TextXAlignment.Center

    return btn, indicator, indText
end

-- Create Noclip (top) and Fly (below)
local noclipBtn, noclipIndicator, noclipText = createToggleButton(controlsFrame, 0, "Noclip")
local flyBtn, flyIndicator, flyText = createToggleButton(controlsFrame, 42, "Fly")

-- Speed slider moved down (where JumpPower used to be)
local speedRow = createSliderRow(controlsFrame, 94, "Speed", 30) -- default placeholder 30 (revert target)
-- speedRow will be visible only when Fly ON
speedRow.Row.Visible = false

-- Revert + Deactivate buttons
local revertBtn = Instance.new("TextButton", controlsFrame)
revertBtn.Size = UDim2.new(0,86,0,30); revertBtn.Position = UDim2.new(0,12,0,132)
revertBtn.BackgroundColor3 = Color3.fromRGB(110,110,110); revertBtn.Text = "Revert"
revertBtn.Font = Enum.Font.GothamBold; revertBtn.TextSize = 14; revertBtn.TextColor3 = Color3.new(1,1,1)
Instance.new("UICorner", revertBtn).CornerRadius = UDim.new(0,6)

local deactivateBtn = Instance.new("TextButton", controlsFrame)
deactivateBtn.Size = UDim2.new(0,110,0,30)
deactivateBtn.Position = UDim2.new(0, 110, 0, 132)
deactivateBtn.BackgroundColor3 = Color3.fromRGB(110,110,110)
deactivateBtn.Text = "Deactivate"
deactivateBtn.Font = Enum.Font.GothamBold
deactivateBtn.TextSize = 14
deactivateBtn.TextColor3 = Color3.new(1,1,1)
Instance.new("UICorner", deactivateBtn).CornerRadius = UDim.new(0,6)

-- Reset reminder label (right of deactivate button) - appear only when deactivated
local resetReminder = Instance.new("TextLabel", controlsFrame)
resetReminder.Size = UDim2.new(0, 60, 0, 30)
resetReminder.Position = UDim2.new(0, 230, 0, 132)
resetReminder.BackgroundTransparency = 1
resetReminder.Text = "reset"
resetReminder.Font = Enum.Font.GothamBold
resetReminder.TextSize = 14
resetReminder.TextColor3 = Color3.new(1,1,1)
resetReminder.TextXAlignment = Enum.TextXAlignment.Left
resetReminder.Visible = false
Instance.new("UICorner", resetReminder).CornerRadius = UDim.new(0,6)

-- Invite box (non-deletable)
local inviteBox = Instance.new("TextBox", mainFrame)
inviteBox.Size = UDim2.new(0.72,0,0,28); inviteBox.Position = UDim2.new(0.06,0,1,-38)
inviteBox.BackgroundTransparency = 0.3; inviteBox.Text = DISCORD_INVITE; inviteBox.ClearTextOnFocus = false
inviteBox.Font = Enum.Font.Gotham; inviteBox.TextSize = 14; inviteBox.TextColor3 = Color3.new(1,1,1)
inviteBox.TextXAlignment = Enum.TextXAlignment.Left
Instance.new("UICorner", inviteBox).CornerRadius = UDim.new(0,6)

local function resizeInviteBox()
    local pad = 18
    local size = TextService:GetTextSize(inviteBox.Text, inviteBox.TextSize, inviteBox.Font, Vector2.new(2000,100))
    local newW = math.clamp(math.ceil(size.X) + pad, 100, FRAME_W - 80)
    inviteBox.Size = UDim2.new(0, newW, 0, 28)
    inviteBox.Position = UDim2.new(0.06, 0, 1, -38)
end
resizeInviteBox()
inviteBox:GetPropertyChangedSignal("Text"):Connect(function() if inviteBox.Text ~= DISCORD_INVITE then inviteBox.Text = DISCORD_INVITE; pcall(function() inviteBox:CaptureFocus(); inviteBox.SelectionStart = 1; inviteBox.CursorPosition = #inviteBox.Text + 1 end); resizeInviteBox() end end)
inviteBox.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then pcall(function() inviteBox:CaptureFocus(); inviteBox.SelectionStart = 1; inviteBox.CursorPosition = #inviteBox.Text + 1 end) end end)

-- Dark overlay for Deactivate
local darkOverlay = Instance.new("Frame", mainFrame)
darkOverlay.Size = UDim2.new(1,0,1,0)
darkOverlay.Position = UDim2.new(0,0,0,0)
darkOverlay.BackgroundColor3 = Color3.fromRGB(0,0,0)
darkOverlay.BackgroundTransparency = 0.6
darkOverlay.ZIndex = mainFrame.ZIndex + 50
darkOverlay.Visible = false
darkOverlay.Active = false
darkOverlay.Selectable = false

-- Drag sticker (small handle)
local dragSticker = Instance.new("ImageButton")
dragSticker.Size = UDim2.new(0,30,0,30); dragSticker.Position = UDim2.new(1,-36,1,-36)
dragSticker.AnchorPoint = Vector2.new(0,0); dragSticker.BackgroundColor3 = Color3.fromRGB(70,70,70)
dragSticker.Image = ""; dragSticker.Parent = mainFrame
Instance.new("UICorner", dragSticker).CornerRadius = UDim.new(0,6)
local originalStickerPos = dragSticker.Position

-- mobile + mouse dragging support for GUI and sliders (kept from previous script)
local function clampPositionToScreen(px, py)
    local cam = workspace.CurrentCamera
    if not cam then return px, py end
    local view = cam.ViewportSize
    local maxX = math.max(0, view.X - mainFrame.AbsoluteSize.X)
    local maxY = math.max(0, view.Y - mainFrame.AbsoluteSize.Y)
    return math.clamp(px, 0, maxX), math.clamp(py, 0, maxY)
end

local isDraggingGUI = false
local dragStartMouse = Vector2.new()
local dragStartPos = Vector2.new()
dragSticker.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        isDraggingGUI = true
        local pos = input.Position or UserInputService:GetMouseLocation()
        dragStartMouse = Vector2.new(pos.X, pos.Y)
        dragStartPos = Vector2.new(mainFrame.AbsolutePosition.X, mainFrame.AbsolutePosition.Y)
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                isDraggingGUI = false
            end
        end)
    end
end)
UserInputService.InputChanged:Connect(function(input)
    if not isDraggingGUI then return end
    if input.UserInputType ~= Enum.UserInputType.MouseMovement and input.UserInputType ~= Enum.UserInputType.Touch then return end
    local pos = input.Position or UserInputService:GetMouseLocation()
    local m = Vector2.new(pos.X, pos.Y)
    local delta = m - dragStartMouse
    local newPos = dragStartPos + delta
    local nx, ny = clampPositionToScreen(newPos.X, newPos.Y)
    mainFrame.Position = UDim2.new(0, nx, 0, ny)
    if dragSticker.Parent == screenGui then
        dragSticker.Position = UDim2.new(0, nx + mainFrame.AbsoluteSize.X - 36, 0, ny + mainFrame.AbsoluteSize.Y + 6)
    end
end)
UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        isDraggingGUI = false
    end
end)

-- Slider logic (drag + tap) - same code used previously, with SNAP
local function enableSliderDrag(slider)
    local track, knob = slider.Track, slider.Knob
    local dragging = false

    knob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    track.InputBegan:Connect(function(input)
        if not (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then return end
        local pos = input.Position or UserInputService:GetMouseLocation()
        local mx = pos.X
        local rel = math.clamp((mx - track.AbsolutePosition.X) / math.max(1, track.AbsoluteSize.X), 0, 1)
        local raw = rel * MAX_VALUE
        local value = math.floor((raw + SNAP/2) / SNAP) * SNAP
        slider.Value = value; slider.Fill.Size = UDim2.new(value / MAX_VALUE, 0, 1, 0)
        slider.Knob.Position = UDim2.new(value / MAX_VALUE, 0, 0.5, 0); slider.SavedValue = value
    end)

    UserInputService.InputChanged:Connect(function(input)
        if not dragging then return end
        if input.UserInputType ~= Enum.UserInputType.MouseMovement and input.UserInputType ~= Enum.UserInputType.Touch then return end
        local pos = input.Position or UserInputService:GetMouseLocation()
        local mx = pos.X
        local rel = math.clamp((mx - track.AbsolutePosition.X) / math.max(1, track.AbsoluteSize.X), 0, 1)
        local raw = rel * MAX_VALUE
        local value = math.floor((raw + SNAP/2) / SNAP) * SNAP
        slider.Value = value; slider.Fill.Size = UDim2.new(value / MAX_VALUE, 0, 1, 0)
        slider.Knob.Position = UDim2.new(value / MAX_VALUE, 0, 0.5, 0); slider.SavedValue = value
    end)
end

enableSliderDrag(speedRow)

-- helpers for value boxes (allow decimals, clamp, fit)
local function sanitizeNumberStringAllowDot(s)
    local cleaned = s:gsub("[^%d%.]", "")
    local firstDot = cleaned:find("%.")
    if firstDot then
        local before = cleaned:sub(1, firstDot)
        local after = cleaned:sub(firstDot+1):gsub("%.", "")
        cleaned = before .. after
    end
    if cleaned == "" then return nil end
    local n = tonumber(cleaned)
    return n, cleaned
end
local function formatNumber(n)
    if type(n) ~= "number" then return "0" end
    local s = tostring(n)
    if s:find("%.") then
        s = s:gsub("(%.%d-)0+$", "%1")
        s = s:gsub("%.$", "")
    end
    return s
end
local function fitTextToBox(box, text)
    local maxSize, minSize = 14, 8
    if not text then text = box.Text end
    local w = box.AbsoluteSize.X
    if w <= 0 then return end
    local size = maxSize
    local pad = 6
    while size < maxSize do
        local ts = TextService:GetTextSize(text, size+1, box.Font, Vector2.new(2000,100))
        if ts.X <= w - pad then size = size + 1 else break end
    end
    while size > minSize do
        local ts = TextService:GetTextSize(text, size, box.Font, Vector2.new(2000,100))
        if ts.X <= w - pad then break end
        size = size - 1
    end
    box.TextSize = size
end

-- live filter for value box
local function liveFilterDigitsAndDot(box)
    box:GetPropertyChangedSignal("Text"):Connect(function()
        local text = box.Text or ""
        local cleaned = text:gsub("[^%d%.]", "")
        local firstDot = cleaned:find("%.")
        if firstDot then
            local before = cleaned:sub(1, firstDot)
            local after = cleaned:sub(firstDot+1):gsub("%.", "")
            cleaned = before .. after
        end
        if cleaned ~= text then
            local cur = 1
            pcall(function() cur = box.CursorPosition end)
            local removed = text:len() - cleaned:len()
            box.Text = cleaned
            pcall(function()
                local newCur = math.clamp(cur - removed, 1, math.max(1, #cleaned + 1))
                box.CursorPosition = newCur
            end)
        end
        pcall(function() fitTextToBox(box, box.Text) end)
    end)
    box:GetPropertyChangedSignal("AbsoluteSize"):Connect(function() pcall(function() fitTextToBox(box, box.Text) end) end)
end

local function hookValueBox(slider)
    local box = slider.ValueBox
    liveFilterDigitsAndDot(box)
    box.FocusLost:Connect(function()
        local txt = box.Text or ""
        local num, _ = sanitizeNumberStringAllowDot(txt)
        if not num then
            box.Text = formatNumber(slider.SavedValue)
            slider.Value = slider.SavedValue
            slider.Fill.Size = UDim2.new(slider.SavedValue / MAX_VALUE, 0, 1, 0)
            slider.Knob.Position = UDim2.new(slider.SavedValue / MAX_VALUE, 0, 0.5, 0)
            fitTextToBox(box, box.Text)
            return
        end
        local clamped = math.clamp(num, 0, MAX_VALUE)
        if clamped ~= num then
            box.Text = formatNumber(slider.SavedValue)
            slider.Value = slider.SavedValue
            slider.Fill.Size = UDim2.new(slider.SavedValue / MAX_VALUE, 0, 1, 0)
            slider.Knob.Position = UDim2.new(slider.SavedValue / MAX_VALUE, 0, 0.5, 0)
            fitTextToBox(box, box.Text)
            return
        end
        slider.Value = clamped
        slider.SavedValue = clamped
        slider.Fill.Size = UDim2.new(clamped / MAX_VALUE, 0, 1, 0)
        slider.Knob.Position = UDim2.new(clamped / MAX_VALUE, 0, 0.5, 0)
        box.Text = formatNumber(clamped)
        fitTextToBox(box, box.Text)
    end)
end

hookValueBox(speedRow)

-- Fly & Noclip state and runtime objects
local flyEnabled = false
local noclipEnabled = false
local deactivated = false

local bv, bg -- BodyVelocity & BodyGyro used for fly
local function cleanupFlyObjects(hrp)
    if bv and bv.Parent then pcall(function() bv:Destroy() end) end
    if bg and bg.Parent then pcall(function() bg:Destroy() end) end
    bv, bg = nil, nil
    if hrp then
        -- restore platform stand to false when disabling fly
        local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
        if hum then pcall(function() hum.PlatformStand = false end) end
    end
end

local function enableNoclip(enable)
    local char = player.Character
    if not char then return end
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            pcall(function() part.CanCollide = not not (not enable and true or false) end) -- set false when enable true
        end
    end
end

local function enableFly(enable)
    local char = player.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hrp or not hum then return end

    if not enable then
        cleanupFlyObjects(hrp)
        return
    end

    -- create BodyVelocity + BodyGyro for smooth movement
    cleanupFlyObjects(hrp)
    bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(9e9, 9e9, 9e9)
    bv.Velocity = Vector3.new(0,0,0)
    bv.P = 9e4
    bv.Parent = hrp

    bg = Instance.new("BodyGyro")
    bg.MaxTorque = Vector3.new(9e9,9e9,9e9)
    bg.P = 9e4
    bg.CFrame = hrp.CFrame
    bg.Parent = hrp

    -- set PlatformStand so regular physics won't fight us
    pcall(function() hum.PlatformStand = true end)
end

-- Apply fly movement every frame while flyEnabled
RunService.Heartbeat:Connect(function(dt)
    if not flyEnabled or deactivated then
        if bv then bv.Velocity = Vector3.new(0,0,0) end
        return
    end
    local char = player.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local hum = char:FindFirstChildOfClass("Humanoid")
    local cam = workspace.CurrentCamera
    if not hrp or not hum or not cam then return end

    -- direction from user input (works for keyboard and mobile joystick)
    local moveDir = hum.MoveDirection -- Vector3 in world-space direction relative to camera
    local speed = speedRow.Value or 30
    speed = math.clamp(speed, 0, MAX_VALUE)

    -- compute velocity: moveDir already is in world-space relative to camera
    local targetVel = Vector3.new(moveDir.X * speed, 0, moveDir.Z * speed)

    -- allow small upward hold if Space is pressed (desktop); on mobile players usually use jump button — include it if pressed
    if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
        targetVel = targetVel + Vector3.new(0, speed * 0.6, 0)
    end
    if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
        targetVel = targetVel - Vector3.new(0, speed * 0.6, 0)
    end

    -- apply to BodyVelocity
    if bv and bv.Parent then
        -- smooth lerp to avoid jitter
        local current = bv.Velocity
        local desired = targetVel
        local lerpVel = current:Lerp(desired, math.clamp(10 * dt, 0, 1))
        bv.Velocity = lerpVel
    end

    -- keep BodyGyro aligned with camera (so player faces direction)
    if bg and bg.Parent then
        local look = CFrame.new(hrp.Position, hrp.Position + cam.CFrame.LookVector * Vector3.new(1,0,1))
        bg.CFrame = look
    end
end)

-- Apply values to humanoid (when not deactivated and when not flying)
local function applyValues()
    local char = player.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum then return end

    -- If not flying, we still allow WalkSpeed to be used for walking (when fly disabled)
    if deactivated then return end

    if not flyEnabled then
        -- set WalkSpeed to speedRow value for normal walking (clamped)
        local val = speedRow.Value or GAME_DEFAULT_WALKSPEED
        hum.WalkSpeed = math.clamp(val, 0, MAX_VALUE)
    end
end

-- Revert button: set speed to 30 and apply if appropriate
revertBtn.MouseButton1Click:Connect(function()
    local default = 30
    speedRow.Value = default
    speedRow.SavedValue = default
    speedRow.Fill.Size = UDim2.new(default / MAX_VALUE, 0, 1, 0)
    speedRow.Knob.Position = UDim2.new(default / MAX_VALUE, 0, 0.5, 0)
    if not deactivated then
        local char = player.Character
        if char then
            local hum = char:FindFirstChildOfClass("Humanoid")
            if hum and not flyEnabled then
                hum.WalkSpeed = math.clamp(default, 0, MAX_VALUE)
            end
            -- if flying, speedRow.Value will be used by flight loop automatically
        end
    end
end)

-- Deactivate toggle (keeps UI but stops script applying WalkSpeed/fly/noclip effects)
deactivateBtn.MouseButton1Click:Connect(function()
    deactivated = not deactivated
    if deactivated then
        deactivateBtn.Text = "Activate"
        darkOverlay.Visible = true
        resetReminder.Visible = true
    else
        deactivateBtn.Text = "Deactivate"
        darkOverlay.Visible = false
        resetReminder.Visible = false
        -- when reactivated, re-apply current states (if fly was ON, ensure flight objects exist)
        if flyEnabled then enableFly(true) end
        if noclipEnabled then enableNoclip(true) end
    end
end)

-- Toggle button handlers
local function setNoclip(on)
    noclipEnabled = on
    noclipText.Text = on and "ON" or "OFF"
    -- if deactivated, do not change the game's collision state
    if deactivated then return end
    enableNoclip(on)
end

local function setFly(on)
    flyEnabled = on
    flyText.Text = on and "ON" or "OFF"
    -- Speed slider visibility toggles with fly
    speedRow.Row.Visible = on
    if deactivated then
        -- don't apply live fly objects while deactivated
        if on then
            -- keep BV/BG nil while deactivated, they will be created on reactivation if fly still on
            cleanupFlyObjects(player.Character and player.Character:FindFirstChild("HumanoidRootPart"))
        else
            cleanupFlyObjects(player.Character and player.Character:FindFirstChild("HumanoidRootPart"))
        end
        return
    end

    if on then
        enableFly(true)
    else
        enableFly(false)
        -- restore humanoid WalkSpeed to GUI slider value (so walking isn't left wrong)
        local char = player.Character
        if char then
            local hum = char:FindFirstChildOfClass("Humanoid")
            if hum then
                hum.WalkSpeed = math.clamp(speedRow.Value or GAME_DEFAULT_WALKSPEED, 0, MAX_VALUE)
            end
        end
    end
end

noclipBtn.MouseButton1Click:Connect(function()
    setNoclip(not noclipEnabled)
end)
flyBtn.MouseButton1Click:Connect(function()
    setFly(not flyEnabled)
end)

-- Ensure toggles show OFF initially
noclipText.Text = "OFF"
flyText.Text = "OFF"
speedRow.Row.Visible = false

-- Minimize behaviour (invite hide + sticker move)
local minimized = false
minBtn.MouseButton1Click:Connect(function()
    minimized = not minimized
    controlsFrame.Visible = not minimized
    inviteBox.Visible = not minimized
    if minimized then
        resetReminder.Visible = false
        mainFrame.Size = UDim2.new(0, FRAME_W, 0, 40)
        dragSticker.Parent = screenGui
        local absX, absY = mainFrame.AbsolutePosition.X, mainFrame.AbsolutePosition.Y
        dragSticker.Position = UDim2.new(0, absX + mainFrame.AbsoluteSize.X - 36, 0, absY + mainFrame.AbsoluteSize.Y + 6)
    else
        mainFrame.Size = UDim2.new(0, FRAME_W, 0, FRAME_H)
        dragSticker.Parent = mainFrame
        dragSticker.Position = originalStickerPos
        if deactivated then resetReminder.Visible = true end
    end
end)

closeBtn.MouseButton1Click:Connect(function() screenGui:Destroy() end)

-- Initialize visuals when character spawns, capture game defaults, and ensure toggles off on death
local defaultsCaptured = false
local function onCharacterAdded(char)
    local hum = char:WaitForChild("Humanoid", 5)
    if hum then
        if not defaultsCaptured then
            GAME_DEFAULT_WALKSPEED = hum.WalkSpeed or GAME_DEFAULT_WALKSPEED
            defaultsCaptured = true
            -- set slider to game default on first spawn
            speedRow.Value = GAME_DEFAULT_WALKSPEED
            speedRow.SavedValue = GAME_DEFAULT_WALKSPEED
            speedRow.Fill.Size = UDim2.new(speedRow.Value / MAX_VALUE, 0, 1, 0)
            speedRow.Knob.Position = UDim2.new(speedRow.Value / MAX_VALUE, 0, 0.5, 0)
            speedRow.ValueBox.Text = formatNumber(speedRow.Value)
            fitTextToBox(speedRow.ValueBox)
        end
    end

    -- On every spawn, ensure Fly & Noclip off
    setFly(false)
    setNoclip(false)
    -- clear fly objects to be safe
    cleanupFlyObjects(char:FindFirstChild("HumanoidRootPart"))
end

if player.Character then
    onCharacterAdded(player.Character)
end
player.CharacterAdded:Connect(onCharacterAdded)

-- Apply values loop (only used for normal WalkSpeed, not flight when flyEnabled)
local running = true
spawn(function()
    while running and screenGui.Parent do
        pcall(applyValues)
        wait(0.04)
    end
end)
screenGui.AncestryChanged:Connect(function() if not screenGui:IsDescendantOf(game) then running = false end end)

-- Keep GUI inside screen bounds each frame
RunService:BindToRenderStep("ClampGUIPosition", Enum.RenderPriority.Camera.Value + 1, function()
    local pos = mainFrame.AbsolutePosition
    local nx, ny = clampPositionToScreen(pos.X, pos.Y)
    if nx ~= pos.X or ny ~= pos.Y then mainFrame.Position = UDim2.new(0, nx, 0, ny) end
    if dragSticker.Parent == screenGui then
        local sx = mainFrame.AbsolutePosition.X + mainFrame.AbsoluteSize.X - 36
        local sy = mainFrame.AbsolutePosition.Y + mainFrame.AbsoluteSize.Y + 6
        dragSticker.Position = UDim2.new(0, sx, 0, sy)
    end
end)
